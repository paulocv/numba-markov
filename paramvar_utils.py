"""
Common utilities for defining a paramvar script for numba-markov model.
"""
import os
from argparse import ArgumentParser
from collections import OrderedDict

import numpy as np

from .model_base import ModelBase, SimResults
from .exec_data import ExecData
from .utils import nav_ipr

# # Switch between these to import from local .utils module or from the (linked) toolbox.file_tools.
# from .utils import str_to_bool_safe, cast_to_export, cast_to_export_list, add_spaces_to_fill
from .toolbox.file_tools import str_to_bool_safe, cast_to_export, cast_to_export_list, add_spaces_to_fill

# -------------------------------------------
# ARGUMENT (ARGV) PARSING PROTOCOL
argv_parser = ArgumentParser()

# ------ Mandatories
# Argv [1]: input file
argv_parser.add_argument("input_file",
                         help="Path for the multi input file, which defines the parameters of the simulations, "
                              "as well as those that will be varied. Must be interpretable by 'read_config_file' "
                              "function from 'file_tools.py' module.")
# Argv [2]: output folder
argv_parser.add_argument("output_folder",
                         help="Path for the output folder, the directory that will store the simulation outputs (both"
                              " the summary file and the individual simulation files). If the path does not exist, it "
                              "is recursively created.")

# ------ Optionals
# Number of processes
argv_parser.add_argument("-p", "--processes", type=int, default=None, metavar="N",
                         help="Number of parallel processes to be used if pathos multiprocessing is on. If not "
                              "informed, allows pathos to determine it by the number of available CPU threads.")

# Summary file overwrite prompt
argv_parser.add_argument("--prompt-overwrite", action="store_true",
                         help="When specified, prompts the user if to overwrite a summary file if the given one "
                              "already exists. Default behavior is to overwrite without prompt.")

# Numba parallel override TODO - Couldn't find a good way :'(

# Pathos parallel override
argv_parser.add_argument("--pathos-multiprocess", type=str_to_bool_safe, default=None, metavar="True/False",
                         help="Overrides the pathos_multiprocess parameter from the input file and the hardcoded "
                              "default.")

# Output writer flush time interval, in seconds
argv_parser.add_argument("--flush-time", type=float, default=60.0, metavar="t(s)",
                         help="Minimum time between consecutive write operations to the summary file. Set to 0 "
                              "to write after each new calculation. Works only on sequential execution.")


# -----------------------------------------------------
# METRICS HANDLING via static classes
# -----------------------------------------------------

def get_metric_flags(input_dict, flag_to_class):
    """Creates the list of metrics to be processed, based on an input dict with T/F flags for each metric."""

    use_metrics = list()
    for key in flag_to_class.keys():  # It is an ordered dict
        # Gets the required flag from input dict, defaulting it to str(False) if not found.
        if str_to_bool_safe(input_dict.get(key, "False")):
            use_metrics.append(key)

    return use_metrics


# -------------------
# GUIDE - How to include a new metrics
# - Implement the required functions in a derived of MetricBase class.
# - Update the metric_flag_to_class dictionary, at the end of this section


class MetricBase:
    """
    Base class for a metric static class.
    A child class will implement the methods and attributes that are required for the metrics to be processed and
    exported in output files.
    """
    @staticmethod
    def get_output_topics(model_class):
        """
        Returns the names of the output topics generated by this metric.

        Parameters
        ----------
        model_class : ModelBase

        Returns
        -------
        output_topics : list
        """
        raise NotImplementedError

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        """
        Extracts the metric from a simulation results (res) objecs and an execution infrastructure bunch (exd).
        Return must be a list of scalar values, regardless of the number of outputs.

        Parameters
        ---------
        res : SimResults
        exd : ExecData
        pop : NLayerMultiplex
        model : ModelBase
        input_dict : dict
        """
        raise NotImplementedError


# METRIC TEMPLATE - JUST COMPY THIS CLASS AND MODIFY IT
# ---------------------------------------------
class MetricEmpty(MetricBase):

    @staticmethod
    def get_output_topics(model_class):
        return []

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        return []
# -----------------------------------------


class MetricStateDensities(MetricBase):
    """Stationary density of each fundamental state of the model."""

    @staticmethod
    def get_output_topics(model_class):
        return ["rho_" + name for name in model_class.state_names]

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        return [np.mean(exd.p_state[s]) for s in range(model.num_states)]


class MetricPrevDensities(MetricBase):
    """Stationary density of each registered prevalence of the model (Ex: I1 = IS + II)."""

    @staticmethod
    def get_output_topics(model_class):
        # Concatenates rho_ with the name of each prevalence registered on the model.
        return ["rho_" + prev_tuple[0] for prev_tuple in model_class.prevalences]

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        # prev[1] gets the list of state indexes of the given prevalence.
        return [np.mean(  # Mean over...
            np.sum(exd.p_state[prev[1]], axis=0))  # ...node density of the prevalence prev...
            for prev in model.prevalences]  # ... for each prevalence.


class MetricNumSteps(MetricBase):
    """Number of steps until convergence of the iterative Markov chain process."""

    @staticmethod
    def get_output_topics(model_class):
        return ["num_steps", ]

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        return [res.num_steps]


class MetricPopSize(MetricBase):
    """Simple outputs the population size, already calculated at its creation."""

    @staticmethod
    def get_output_topics(model_class):
        return ["pop_size", ]

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        return [pop.size]


class MetricStateIPR(MetricBase):

    @staticmethod
    def get_output_topics(model_class):
        return ["ipr_" + name for name in model_class.state_names]

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        return [nav_ipr(exd.p_state[s]) for s in range(model.num_states)]


class MetricPrevIPR(MetricBase):
    @staticmethod
    def get_output_topics(model_class):
        return ["ipr_" + prev_tuple[0] for prev_tuple in model_class.prevalences]

    @staticmethod
    def calc_metric(res, exd, pop, model, input_dict):
        return [nav_ipr(  # IPR of...
            np.sum(exd.p_state[prev[1]], axis=0))  # ...node density of the prevalence prev...
            for prev in model.prevalences]  # ... for each prevalence.

# -----------------------------------------------------------


# Dictionary that stores the metric flags and their respective processor classes.
# The dict is ordered, so outputs can have a consistent order among implementations.
METRIC_TO_CLASS = OrderedDict(
    calc_pop_size=MetricPopSize,
    calc_state_densities=MetricStateDensities,
    calc_prevalence_densities=MetricPrevDensities,
    calc_state_ipr=MetricStateIPR,
    calc_prevalence_ipr=MetricPrevIPR,
    calc_num_steps=MetricNumSteps,
)


# -----------------------------------------------------
# HEAVY SIMULATION OUTPUT DATA WITH 'EXPORT' STATIC CLASSES
# -----------------------------------------------------

class ExportBase:

    @staticmethod
    def get_fname_suffixes(model):
        """
        Must return a list of strings, each with the suffix of each exported file (except file extension).

        Parameters
        ----------
        model: ModelBase

        Returns
        -------
        lout: list[str]
        """
        return []

    @staticmethod
    def info_to_header(res, exd, pop, model, input_dict):
        """
        Must return a list of strings, each with extra info that's written into the header after its main contents.

        Parameters
        ----------
        res: SimResults
        exd: ExecData
        pop: NLayerMultiplex
        model: ModelBase
        input_dict: dict[str, str]

        Returns
        -------
        lout: list[str]
        """
        return []

    @staticmethod
    def get_fdata(res, exd, pop, model, input_dict):
        """
        Must return a list of strings, each with the casted simulation data to be exported.

        Parameters
        ----------
        res: SimResults
        exd: ExecData
        pop: NLayerMultiplex
        model: ModelBase
        input_dict: dict[str, str]

        Returns
        -------
        lout: list[str]
        """
        return []


class ExportState(ExportBase):

    @staticmethod
    def get_fname_suffixes(model):
        """ Just a single file with all states and time stamps. """
        return [os.path.join("states", "sim")]

    @staticmethod
    def info_to_header(res, exd, pop, model, input_dict):
        """ Exports overall state densities as a function of time. """
        output_topics = ["rho_{}".format(name) for name in model.state_names]
        out = "> outputs = "
        out += ", ".join(output_topics) + "\n\n"  # List of outputs
        for name in ["t"] + output_topics:  # Visual header
            out += add_spaces_to_fill(name, 16)
        out += "\n"

        return [out]

    @staticmethod
    def get_fdata(res, exd, pop, model, input_dict):
        """ Exports overall state densities as a function of time."""
        out = ""
        for t, p_array in zip(res.t_tseries, res.rho_tseries):
            out += cast_to_export(t) + "\t"
            out += cast_to_export_list(p_array, float_fmt="{:12.6E}")
            out += "\n"

        return [out]


class ExportNodeState:
    pass


# Dictionary that stores the export flags and their respective processor classes.
# The dict is ordered, so outputs can have a consistent order among implementations.
EXPORT_TO_CLASS = OrderedDict(
    export_tseries_state=ExportState,
    export_tseries_nodestate=ExportNodeState,
)
